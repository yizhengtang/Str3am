"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DeviceCurrentSession = void 0;
const protobuf_1 = require("@trezor/protobuf");
const schema_utils_1 = require("@trezor/schema-utils");
const utils_1 = require("@trezor/utils");
const constants_1 = require("../constants");
const events_1 = require("../events");
const debug_1 = require("../utils/debug");
const blacklist = {
    PassphraseAck: ['passphrase'],
    CipheredKeyValue: ['value'],
    GetPublicKey: ['address_n'],
    PublicKey: ['node', 'xpub'],
    DecryptedMessage: ['message', 'address'],
    Features: true,
};
const filterForLog = (type, msg) => blacklist[type] === true
    ? '(redacted...)'
    : (blacklist[type] ?? []).reduce((prev, cur) => ({ ...prev, [cur]: '(redacted...)' }), msg);
const logger = (0, debug_1.initLog)('DeviceCommands');
const success = (payload) => ({ success: true, payload });
const error = (error) => ({ success: false, error });
const fail = (msg, cause) => error(new Error(msg, cause ? { cause } : undefined));
const disposed = () => error(constants_1.ERRORS.TypedError('Runtime', 'typedCall: DeviceCommands already disposed'));
class DeviceCurrentSession {
    device;
    transport;
    protocol;
    session;
    disposed;
    callPromise;
    abortController;
    constructor(device, transport, protocol, session) {
        this.device = device;
        this.transport = transport;
        this.protocol = protocol;
        this.session = session;
        this.disposed = false;
    }
    isDisposed() {
        return this.disposed;
    }
    async typedCall(type, resType, msg = {}) {
        (0, schema_utils_1.Assert)(protobuf_1.MessagesSchema.MessageType.properties[type], msg);
        this.abortController = new AbortController();
        const { signal } = this.abortController;
        const abortPromise = new Promise(resolve => signal.addEventListener('abort', () => resolve(error(signal.reason))));
        const callPromise = this.callLoop(type, msg, abortPromise);
        this.callPromise = callPromise;
        const response = await callPromise;
        this.callPromise = undefined;
        this.abortController = undefined;
        if (!response.success)
            throw response.error;
        const { payload } = response;
        if (!(Array.isArray(resType) ? resType : resType.split('|')).includes(payload.type)) {
            await (0, utils_1.scheduleAction)(abort => this.transport.receive({
                session: this.session,
                protocol: this.protocol,
                signal: abort,
            }), { timeout: 500 }).catch(() => { });
            throw constants_1.ERRORS.TypedError('Runtime', `assertType: Response of unexpected type: ${payload.type}. Should be ${resType}`);
        }
        return payload;
    }
    needCancelWorkaround() {
        return (this.transport.name === 'BridgeTransport' &&
            !utils_1.versionUtils.isNewer(this.transport.version, '2.0.28'));
    }
    async callLoop(type, msg, abortPromise) {
        let [name, data] = [type, msg];
        const { protocol, session } = this;
        let pinUnlocked = false;
        while (true) {
            if (this.disposed)
                return disposed();
            const callPromise = this.call({ session, name, data, protocol });
            const abortedDuringCall = await Promise.race([
                callPromise.then(() => false),
                abortPromise.then(() => true),
            ]);
            if (name === 'ButtonAck' && abortedDuringCall && !this.disposed) {
                if (this.needCancelWorkaround()) {
                    try {
                        await (0, utils_1.resolveAfter)(1);
                        await this.device.acquire();
                        await this.device.getCurrentSession().cancelCall(false);
                        await this.device.release();
                    }
                    catch {
                    }
                }
                else {
                    await this.cancelCall(false);
                }
            }
            const response = await callPromise;
            if (this.disposed)
                return disposed();
            if (!response.success)
                return response;
            const res = response.payload;
            switch (res.type) {
                case 'Failure': {
                    const { code, message } = res.message;
                    const err = message ||
                        (code === 'Failure_FirmwareError' && 'Firmware installation failed') ||
                        (code === 'Failure_ActionCancelled' && 'Action cancelled by user') ||
                        'Failure_UnknownMessage';
                    return error(new constants_1.ERRORS.TrezorError(code || 'Failure_UnknownCode', err));
                }
                case 'ButtonRequest': {
                    if (res.message.code === 'ButtonRequest_PassphraseEntry') {
                        this.device.emit(events_1.DEVICE.PASSPHRASE_ON_DEVICE);
                    }
                    else {
                        this.device.emit(events_1.DEVICE.BUTTON, {
                            device: this.device,
                            payload: res.message,
                        });
                    }
                    [name, data] = ['ButtonAck', {}];
                    break;
                }
                case 'PinMatrixRequest': {
                    const promptRes = await Promise.race([
                        this.device.prompt(events_1.DEVICE.PIN, { type: res.message.type }),
                        abortPromise,
                    ]);
                    if (!promptRes.success) {
                        const cancelRes = await this.cancelCall();
                        return cancelRes.success ? promptRes : cancelRes;
                    }
                    pinUnlocked = true;
                    [name, data] = ['PinMatrixAck', { pin: promptRes.payload }];
                    break;
                }
                case 'PassphraseRequest': {
                    const promptRes = await Promise.race([
                        this.device.prompt(events_1.DEVICE.PASSPHRASE, {}),
                        abortPromise,
                    ]);
                    if (!promptRes.success) {
                        const cancelRes = await this.cancelCall();
                        return cancelRes.success ? promptRes : cancelRes;
                    }
                    const payload = promptRes.payload.passphraseOnDevice
                        ? { on_device: true }
                        : { passphrase: promptRes.payload.value.normalize('NFKD') };
                    [name, data] = ['PassphraseAck', payload];
                    break;
                }
                case 'WordRequest': {
                    const promptRes = await Promise.race([
                        this.device.prompt(events_1.DEVICE.WORD, { type: res.message.type }),
                        abortPromise,
                    ]);
                    if (!promptRes.success) {
                        const cancelRes = await this.cancelCall();
                        return cancelRes.success ? promptRes : cancelRes;
                    }
                    [name, data] = ['WordAck', { word: promptRes.payload }];
                    break;
                }
                default: {
                    if (!this.disposed && pinUnlocked && !this.device.features.unlocked) {
                        await this.device.getFeatures();
                    }
                    return success(res);
                }
            }
        }
    }
    async call(params) {
        logger.debug('Sending', params.name, filterForLog(params.name, params.data));
        const result = await this.transport.call(params);
        if (result.success) {
            const { type, message } = result.payload;
            logger.debug('Received', type, filterForLog(type, message));
        }
        else {
            logger.warn('Received transport error', result.error, result.message);
        }
        return result.success ? success(result.payload) : fail(result.error, 'transport-error');
    }
    async cancelCall(expectResponse = true) {
        if (this.disposed)
            return Promise.resolve(disposed());
        const { protocol, session } = this;
        const cancelArgs = { session, name: 'Cancel', data: {}, protocol };
        const response = expectResponse
            ? await this.transport.call(cancelArgs)
            : await this.transport.send(cancelArgs);
        return response.success ? success(response.payload) : fail(response.error);
    }
    async abort(reason) {
        this.abortController?.abort(reason);
        await this.callPromise;
    }
    async dispose() {
        if (!this.disposed) {
            this.disposed = true;
            await this.abort(constants_1.ERRORS.TypedError('Runtime', 'typedCall: DeviceCommands already disposed'));
        }
    }
}
exports.DeviceCurrentSession = DeviceCurrentSession;
//# sourceMappingURL=DeviceCurrentSession.js.map