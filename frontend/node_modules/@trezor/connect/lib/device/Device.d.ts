import { TransportProtocol } from '@trezor/protocol';
import { Session } from '@trezor/transport';
import { type Descriptor, type Transport } from '@trezor/transport';
import { TypedEmitter } from '@trezor/utils';
import { PROTO } from '../constants';
import { TypedCallProvider } from './DeviceCurrentSession';
import { IStateStorage } from './StateStorage';
import { DEVICE, DeviceButtonRequestPayload, DeviceVersionChanged, UiResponsePassphrase, UiResponsePin, UiResponseWord } from '../events';
import { DeviceFirmwareStatus, DeviceState, Device as DeviceTyped, DeviceUniquePath, FirmwareType, ReleaseInfo, UnavailableCapabilities, VersionArray } from '../types';
type RunOptions = {
    skipFinalReload?: boolean;
    keepSession?: boolean;
    useCardanoDerivation?: boolean;
    skipFirmwareChecks?: boolean;
    skipLanguageChecks?: boolean;
};
export declare const CANCEL_TIMEOUT = 1000;
export declare const GET_FEATURES_TIMEOUT = 3000;
export declare const GET_FEATURES_TIMEOUT_REACT_NATIVE = 20000;
type Result<T> = {
    success: true;
    payload: T;
} | {
    success: false;
    error: Error;
};
export interface DeviceEvents {
    [DEVICE.PIN]: {
        type: PROTO.PinMatrixRequestType | undefined;
        callback: (response: Result<UiResponsePin['payload']>) => void;
    };
    [DEVICE.WORD]: {
        type: PROTO.WordRequestType;
        callback: (response: Result<UiResponseWord['payload']>) => void;
    };
    [DEVICE.PASSPHRASE]: {
        callback: (response: Result<UiResponsePassphrase['payload']>) => void;
    };
    [DEVICE.PASSPHRASE_ON_DEVICE]: void;
    [DEVICE.BUTTON]: {
        device: Device;
        payload: DeviceButtonRequestPayload;
    };
    [DEVICE.FIRMWARE_VERSION_CHANGED]: DeviceVersionChanged['payload'];
}
type DeviceLifecycle = typeof DEVICE.CONNECT | typeof DEVICE.CONNECT_UNACQUIRED | typeof DEVICE.DISCONNECT | typeof DEVICE.CHANGED;
type DeviceLifecycleListener = (lifecycle: DeviceLifecycle) => void;
type DeviceParams = {
    id: DeviceUniquePath;
    transport: Transport;
    descriptor: Descriptor;
    listener: DeviceLifecycleListener;
};
export declare class Device extends TypedEmitter<DeviceEvents> {
    readonly transport: Transport;
    readonly protocol: TransportProtocol;
    readonly transportPath: import("@trezor/transport/lib/types").PathPublic;
    private readonly transportDescriptorType;
    private readonly bluetoothProps;
    private session;
    private transportSessionOwner;
    private lastAcquiredHere;
    private unreadableError?;
    private _firmwareStatus;
    get firmwareStatus(): DeviceFirmwareStatus;
    private _firmwareRelease?;
    get firmwareRelease(): ReleaseInfo | null | undefined;
    private _features;
    get features(): {
        _passphrase_cached?: boolean | undefined;
        busy?: boolean | undefined;
        homescreen_format?: "Toif" | "Jpeg" | "ToiG" | undefined;
        hide_passphrase_from_host?: boolean | undefined;
        unit_color?: number | undefined;
        unit_btconly?: boolean | undefined;
        homescreen_width?: number | undefined;
        homescreen_height?: number | undefined;
        bootloader_locked?: boolean | undefined;
        language_version_matches?: boolean | undefined;
        unit_packaging?: number | undefined;
        haptic_feedback?: boolean | undefined;
        recovery_type?: "NormalRecovery" | "DryRun" | "UnlockRepeatedBackup" | undefined;
        optiga_sec?: number | undefined;
        vendor: string;
        major_version: number;
        minor_version: number;
        patch_version: number;
        bootloader_mode: boolean | null;
        device_id: string | null;
        pin_protection: boolean | null;
        passphrase_protection: boolean | null;
        language: string | null;
        label: string | null;
        initialized: boolean | null;
        revision: string | null;
        bootloader_hash: string | null;
        imported: boolean | null;
        unlocked: boolean | null;
        firmware_present: boolean | null;
        backup_availability: "NotAvailable" | "Required" | "Available" | null;
        flags: number | null;
        model: string;
        fw_major: number | null;
        fw_minor: number | null;
        fw_patch: number | null;
        fw_vendor: string | null;
        unfinished_backup: boolean | null;
        no_backup: boolean | null;
        recovery_status: "Nothing" | "Recovery" | "Backup" | null;
        capabilities: ("Capability_Bitcoin" | "Capability_Bitcoin_like" | "Capability_Binance" | "Capability_Cardano" | "Capability_Crypto" | "Capability_EOS" | "Capability_Ethereum" | "Capability_Lisk" | "Capability_Monero" | "Capability_NEM" | "Capability_Ripple" | "Capability_Stellar" | "Capability_Tezos" | "Capability_U2F" | "Capability_Shamir" | "Capability_ShamirGroups" | "Capability_PassphraseEntry" | "Capability_Solana" | "Capability_Translations" | "Capability_Brightness" | "Capability_Haptic")[];
        backup_type: "Bip39" | "Slip39_Basic" | "Slip39_Advanced" | "Slip39_Single_Extendable" | "Slip39_Basic_Extendable" | "Slip39_Advanced_Extendable" | null;
        sd_card_present: boolean | null;
        sd_protection: boolean | null;
        wipe_code_protection: boolean | null;
        session_id: string | null;
        passphrase_always_on_device: boolean | null;
        safety_checks: "Strict" | "PromptAlways" | "PromptTemporarily" | null;
        auto_lock_delay_ms: number | null;
        display_rotation: "North" | "East" | "South" | "West" | null;
        experimental_features: boolean | null;
        internal_model: PROTO.DeviceModelInternal;
    };
    private _featuresNeedsReload;
    private acquirePromise?;
    private releasePromise?;
    private runPromise?;
    private keepTransportSession;
    private currentSession?;
    private loaded;
    private inconsistent;
    private firstRunPromise;
    private instance;
    private state;
    private stateStorage?;
    private _unavailableCapabilities;
    get unavailableCapabilities(): Readonly<UnavailableCapabilities>;
    private _firmwareType?;
    get firmwareType(): FirmwareType | undefined;
    private name;
    private color?;
    private availableTranslations;
    private authenticityChecks;
    private readonly uniquePath;
    private readonly emitLifecycle;
    private sessionDfd?;
    handshakeFinished: boolean;
    constructor({ id, transport, descriptor, listener }: DeviceParams);
    private getSessionChangePromise;
    private waitAndCompareSession;
    acquire(): import("@trezor/transport/lib/types").AsyncResultWithTypedError<Session, "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "descriptor not found" | "wrong previous session" | "LIBUSB_ERROR_ACCESS">;
    release(): Promise<import("@trezor/transport/lib/types").Success<null> | {
        success: false;
        error: "Network request failed" | "Wrong result type." | "device disconnected during action" | "unexpected error" | "session not found" | "Aborted by timeout" | "Aborted by signal" | "This transport can not be used in this environment" | "device not found" | "Unable to open device" | "wrong previous session";
        message?: string;
    } | undefined>;
    releaseTransportSession(): void;
    cleanup(release?: boolean): Promise<void>;
    handshake(delay?: number): Promise<void>;
    updateDescriptor(descriptor: Descriptor): Promise<void>;
    run(fn?: () => Promise<void>, options?: RunOptions): Promise<void>;
    override(error: Error): Promise<void>;
    interruptionFromUser(error: Error): Promise<void>;
    usedElsewhere(): void;
    private _runInner;
    getCurrentSession(): TypedCallProvider;
    getCommands(): {
        unlockPath: (params?: PROTO.UnlockPath) => Promise<{
            type: "UnlockedPathRequest";
            message: {
                mac: string;
            };
        }>;
        getPublicKey: (params: PROTO.GetPublicKey, unlock?: PROTO.UnlockPath) => Promise<{
            descriptor?: string | undefined;
            root_fingerprint?: number | undefined;
            node: {
                private_key?: string | undefined;
                public_key: string;
                depth: number;
                fingerprint: number;
                child_num: number;
                chain_code: string;
            };
            xpub: string;
        }>;
        getAddress: ({ address_n, show_display, multisig, script_type, chunkify }: PROTO.GetAddress, coinInfo: import("../types").BitcoinNetworkInfo) => Promise<{
            mac?: string | undefined;
            address: string;
        }>;
        ethereumGetPublicKey: ({ address_n, show_display, }: PROTO.EthereumGetPublicKey) => Promise<{
            node: {
                private_key?: string | undefined;
                public_key: string;
                depth: number;
                fingerprint: number;
                child_num: number;
                chain_code: string;
            };
            xpub: string;
        }>;
        ethereumGetAddress: (params: PROTO.EthereumGetAddress) => Promise<{
            _old_address?: string | undefined;
            address: string;
        }>;
        getHDNode: (params: PROTO.GetPublicKey, options: {
            coinInfo: import("../types").BitcoinNetworkInfo;
            validation?: boolean;
            unlockPath?: PROTO.UnlockPath;
        }) => Promise<{
            path: number[];
            publicKey: string;
            serializedPath: string;
        } & {
            descriptor?: string | undefined;
            xpubSegwit?: string | undefined;
            descriptorChecksum?: string | undefined;
            depth: number;
            fingerprint: number;
            chainCode: string;
            childNum: number;
            xpub: string;
        }>;
        preauthorize: (throwError: boolean) => Promise<boolean>;
        getAccountDescriptor: (coinInfo: import("../types").CoinInfo, indexOrPath: number | number[], derivationType?: PROTO.CardanoDerivationType) => Promise<{
            descriptor: string;
            legacyXpub?: string;
            address_n: number[];
            descriptorChecksum?: string;
        }>;
        typedCall: PROTO.TypedCall;
    };
    setInstance(instance?: number): void;
    getInstance(): number;
    getState(): DeviceState | undefined;
    setState(state?: Partial<DeviceState>): void;
    validateState(preauthorized?: boolean): Promise<`${string}@${string}:${number}` | undefined>;
    initialize(useCardanoDerivation: boolean): Promise<void>;
    initStorage(storage: IStateStorage): void;
    getFeatures(): Promise<void>;
    private checkFirmwareHashWithRetries;
    private checkFirmwareHash;
    private checkFirmwareRevisionWithRetries;
    private checkFirmwareRevision;
    changeLanguage({ language, binary, }: {
        language?: undefined;
        binary: ArrayBuffer;
    } | {
        language: string;
        binary?: undefined;
    }): Promise<{
        message: string;
    }>;
    private _uploadTranslationData;
    private _updateFeatures;
    prompt<T extends typeof DEVICE.PIN | typeof DEVICE.PASSPHRASE | typeof DEVICE.WORD>(type: T, args: Omit<DeviceEvents[T], 'callback'>): Promise<Parameters<DeviceEvents[T]["callback"]>[0]>;
    isUnacquired(): boolean;
    isUnreadable(): boolean;
    disconnect(): Promise<void>;
    isBootloader(): boolean;
    isInitialized(): boolean;
    isSeedless(): boolean;
    isInconsistent(): boolean;
    getVersion(): VersionArray | undefined;
    atLeast(versions: string[] | string): boolean;
    isUsed(): boolean;
    isUsedHere(): boolean;
    isUsedElsewhere(): boolean;
    isRunning(): boolean;
    isLoaded(): boolean;
    waitForFirstRun(): Promise<boolean>;
    getUniquePath(): DeviceUniquePath;
    isT1(): boolean;
    hasUnexpectedMode(allow: string[], require: string[]): "ui-device_bootloader_mode" | "ui-device_not_in_bootloader_mode" | "ui-device_not_initialized" | "ui-device_seedless" | null;
    dispose(): void;
    private getMode;
    toMessageObject(): DeviceTyped;
}
export {};
//# sourceMappingURL=Device.d.ts.map