const isArray = (attempts) => Array.isArray(attempts);
const resolveAfterMs = (ms, clear) => new Promise((resolve, reject) => {
    if (clear.aborted)
        return reject();
    if (ms === undefined)
        return resolve();
    let timeout;
    const onClear = () => {
        clearTimeout(timeout);
        clear.removeEventListener('abort', onClear);
        reject();
    };
    timeout = setTimeout(() => {
        clear.removeEventListener('abort', onClear);
        resolve();
    }, ms);
    clear.addEventListener('abort', onClear);
});
const rejectAfterMs = (ms, reason, clear) => new Promise((_, reject) => {
    if (clear.aborted)
        return reject();
    let timeout;
    const onClear = () => {
        clearTimeout(timeout);
        clear.removeEventListener('abort', onClear);
        reject();
    };
    timeout = setTimeout(() => {
        clear.removeEventListener('abort', onClear);
        reject(reason);
    }, ms);
    clear.addEventListener('abort', onClear);
});
const maybeRejectAfterMs = (ms, reason, clear) => ms === undefined ? [] : [rejectAfterMs(ms, reason, clear)];
const rejectWhenAborted = (signal, clear) => new Promise((_, reject) => {
    if (clear.aborted)
        return reject();
    const errorSignal = new Error('Aborted by signal');
    if (signal?.aborted)
        return reject(errorSignal);
    const onAbort = () => reject(errorSignal);
    signal?.addEventListener('abort', onAbort);
    const onClear = () => {
        signal?.removeEventListener('abort', onAbort);
        clear.removeEventListener('abort', onClear);
        reject();
    };
    clear.addEventListener('abort', onClear);
});
const resolveAction = async (action, clear) => {
    const aborter = new AbortController();
    if (clear.aborted)
        aborter.abort();
    const onClear = () => {
        clear.removeEventListener('abort', onClear);
        aborter.abort();
    };
    clear.addEventListener('abort', onClear);
    try {
        return await new Promise(resolve => resolve(action(aborter.signal)));
    }
    finally {
        if (!clear.aborted)
            clear.removeEventListener('abort', onClear);
    }
};
const attemptLoop = async (attempts, attempt, failure, clear) => {
    for (let a = 0; a < attempts - 1; a++) {
        if (clear.aborted)
            break;
        const aborter = new AbortController();
        const onClear = () => aborter.abort();
        clear.addEventListener('abort', onClear);
        try {
            return await attempt(a, aborter.signal);
        }
        catch (error) {
            onClear();
            await failure(a, error);
        }
        finally {
            clear.removeEventListener('abort', onClear);
        }
    }
    return clear.aborted ? Promise.reject() : attempt(attempts - 1, clear);
};
export const scheduleAction = async (action, params) => {
    const { signal, delay, attempts, timeout, deadline, gap, attemptFailureHandler } = params;
    const deadlineMs = deadline && deadline - Date.now();
    const attemptCount = isArray(attempts)
        ? attempts.length
        : attempts ?? (deadline ? Infinity : 1);
    const clearAborter = new AbortController();
    const clear = clearAborter.signal;
    const getParams = isArray(attempts)
        ? (attempt) => attempts[attempt]
        : () => ({ timeout, gap });
    const errorDeadline = new Error('Aborted by deadline');
    const errorTimeout = new Error('Aborted by timeout');
    try {
        return await Promise.race([
            rejectWhenAborted(signal, clear),
            ...maybeRejectAfterMs(deadlineMs, errorDeadline, clear),
            resolveAfterMs(delay, clear).then(() => attemptLoop(attemptCount, (attempt, abort) => Promise.race([
                ...maybeRejectAfterMs(getParams(attempt).timeout, errorTimeout, clear),
                resolveAction(action, abort),
            ]), (attempt, error) => {
                const errorHandlerResult = attemptFailureHandler?.(error);
                return errorHandlerResult
                    ? Promise.reject(errorHandlerResult)
                    : resolveAfterMs(getParams(attempt).gap ?? 0, clear);
            }, clear)),
        ]);
    }
    finally {
        clearAborter.abort();
    }
};
//# sourceMappingURL=scheduleAction.js.map