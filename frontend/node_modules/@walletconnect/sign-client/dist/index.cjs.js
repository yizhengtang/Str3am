"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var h=require("@walletconnect/core"),X=require("@walletconnect/logger"),Ie=require("@walletconnect/types"),T=require("@walletconnect/time"),i=require("@walletconnect/utils"),Re=require("events"),w=require("@walletconnect/jsonrpc-utils");function Ue(S){return S&&typeof S=="object"&&"default"in S?S:{default:S}}var ke=Ue(Re);const ae="wc",ce=2,le="client",J=`${ae}@${ce}:${le}:`,z={name:le,logger:"error",controller:!1,relayUrl:"wss://relay.walletconnect.org"},$e={session_proposal:"session_proposal",session_update:"session_update",session_extend:"session_extend",session_ping:"session_ping",session_delete:"session_delete",session_expire:"session_expire",session_request:"session_request",session_request_sent:"session_request_sent",session_event:"session_event",proposal_expire:"proposal_expire",session_authenticate:"session_authenticate",session_request_expire:"session_request_expire",session_connect:"session_connect"},Fe={database:":memory:"},pe="WALLETCONNECT_DEEPLINK_CHOICE",Ke={created:"history_created",updated:"history_updated",deleted:"history_deleted",sync:"history_sync"},Ge="history",Ye="0.3",Te="proposal",He=T.THIRTY_DAYS,he="Proposal expired",Ne="session",M=T.SEVEN_DAYS,ve="engine",P={wc_sessionPropose:{req:{ttl:T.FIVE_MINUTES,prompt:!0,tag:1100},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1101},reject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1120},autoReject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1121}},wc_sessionSettle:{req:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1102},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1103}},wc_sessionUpdate:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1104},res:{ttl:T.ONE_DAY,prompt:!1,tag:1105}},wc_sessionExtend:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1106},res:{ttl:T.ONE_DAY,prompt:!1,tag:1107}},wc_sessionRequest:{req:{ttl:T.FIVE_MINUTES,prompt:!0,tag:1108},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1109}},wc_sessionEvent:{req:{ttl:T.FIVE_MINUTES,prompt:!0,tag:1110},res:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1111}},wc_sessionDelete:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1112},res:{ttl:T.ONE_DAY,prompt:!1,tag:1113}},wc_sessionPing:{req:{ttl:T.ONE_DAY,prompt:!1,tag:1114},res:{ttl:T.ONE_DAY,prompt:!1,tag:1115}},wc_sessionAuthenticate:{req:{ttl:T.ONE_HOUR,prompt:!0,tag:1116},res:{ttl:T.ONE_HOUR,prompt:!1,tag:1117},reject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1118},autoReject:{ttl:T.FIVE_MINUTES,prompt:!1,tag:1119}}},B={min:T.FIVE_MINUTES,max:T.SEVEN_DAYS},x={idle:"IDLE",active:"ACTIVE"},de={eth_sendTransaction:{key:""},eth_sendRawTransaction:{key:""},wallet_sendCalls:{key:""},solana_signTransaction:{key:"signature"},solana_signAllTransactions:{key:"transactions"},solana_signAndSendTransaction:{key:"signature"}},fe="request",Oe=["wc_sessionPropose","wc_sessionRequest","wc_authRequest","wc_sessionAuthenticate"],Pe="wc",je=1.5,qe="auth",Ae="authKeys",Ce="pairingTopics",Ve="requests",G=`${Pe}@${1.5}:${qe}:`,Y=`${G}:PUB_KEY`;var Qe=Object.defineProperty,Xe=Object.defineProperties,Je=Object.getOwnPropertyDescriptors,Le=Object.getOwnPropertySymbols,ze=Object.prototype.hasOwnProperty,Be=Object.prototype.propertyIsEnumerable,ue=(S,o,e)=>o in S?Qe(S,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):S[o]=e,f=(S,o)=>{for(var e in o||(o={}))ze.call(o,e)&&ue(S,e,o[e]);if(Le)for(var e of Le(o))Be.call(o,e)&&ue(S,e,o[e]);return S},C=(S,o)=>Xe(S,Je(o)),l=(S,o,e)=>ue(S,typeof o!="symbol"?o+"":o,e);class We extends Ie.IEngine{constructor(o){super(o),l(this,"name",ve),l(this,"events",new ke.default),l(this,"initialized",!1),l(this,"requestQueue",{state:x.idle,queue:[]}),l(this,"sessionRequestQueue",{state:x.idle,queue:[]}),l(this,"requestQueueDelay",T.ONE_SECOND),l(this,"expectedPairingMethodMap",new Map),l(this,"recentlyDeletedMap",new Map),l(this,"recentlyDeletedLimit",200),l(this,"relayMessageCache",[]),l(this,"pendingSessions",new Map),l(this,"init",async()=>{this.initialized||(await this.cleanup(),this.registerRelayerEvents(),this.registerExpirerEvents(),this.registerPairingEvents(),await this.registerLinkModeListeners(),this.client.core.pairing.register({methods:Object.keys(P)}),this.initialized=!0,setTimeout(()=>{this.sessionRequestQueue.queue=this.getPendingSessionRequests(),this.processSessionRequestQueue()},T.toMiliseconds(this.requestQueueDelay)))}),l(this,"connect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();const t=C(f({},e),{requiredNamespaces:e.requiredNamespaces||{},optionalNamespaces:e.optionalNamespaces||{}});await this.isValidConnect(t);const{pairingTopic:s,requiredNamespaces:r,optionalNamespaces:n,sessionProperties:a,relays:c}=t;let p=s,E,y=!1;try{if(p){const N=this.client.core.pairing.pairings.get(p);this.client.logger.warn("connect() with existing pairing topic is deprecated and will be removed in the next major release."),y=N.active}}catch(N){throw this.client.logger.error(`connect() -> pairing.get(${p}) failed`),N}if(!p||!y){const{topic:N,uri:L}=await this.client.core.pairing.create();p=N,E=L}if(!p){const{message:N}=i.getInternalError("NO_MATCHING_KEY",`connect() pairing topic: ${p}`);throw new Error(N)}const u=await this.client.core.crypto.generateKeyPair(),g=P.wc_sessionPropose.req.ttl||T.FIVE_MINUTES,_=i.calcExpiry(g),m=C(f({requiredNamespaces:r,optionalNamespaces:n,relays:c??[{protocol:h.RELAYER_DEFAULT_PROTOCOL}],proposer:{publicKey:u,metadata:this.client.metadata},expiryTimestamp:_,pairingTopic:p},a&&{sessionProperties:a}),{id:w.payloadId()}),v=i.engineEvent("session_connect",m.id),{reject:d,resolve:R,done:V}=i.createDelayedPromise(g,he),O=({id:N})=>{N===m.id&&(this.client.events.off("proposal_expire",O),this.pendingSessions.delete(m.id),this.events.emit(v,{error:{message:he,code:0}}))};return this.client.events.on("proposal_expire",O),this.events.once(v,({error:N,session:L})=>{this.client.events.off("proposal_expire",O),N?d(N):L&&R(L)}),await this.sendRequest({topic:p,method:"wc_sessionPropose",params:m,throwOnFailedPublish:!0,clientRpcId:m.id}),await this.setProposal(m.id,m),{uri:E,approval:V}}),l(this,"pair",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{return await this.client.core.pairing.pair(e)}catch(t){throw this.client.logger.error("pair() failed"),t}}),l(this,"approve",async e=>{var t,s,r;const n=this.client.core.eventClient.createEvent({properties:{topic:(t=e?.id)==null?void 0:t.toString(),trace:[h.EVENT_CLIENT_SESSION_TRACES.session_approve_started]}});try{this.isInitialized(),await this.confirmOnlineStateOrThrow()}catch(q){throw n.setError(h.EVENT_CLIENT_SESSION_ERRORS.no_internet_connection),q}try{await this.isValidProposalId(e?.id)}catch(q){throw this.client.logger.error(`approve() -> proposal.get(${e?.id}) failed`),n.setError(h.EVENT_CLIENT_SESSION_ERRORS.proposal_not_found),q}try{await this.isValidApprove(e)}catch(q){throw this.client.logger.error("approve() -> isValidApprove() failed"),n.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_approve_namespace_validation_failure),q}const{id:a,relayProtocol:c,namespaces:p,sessionProperties:E,sessionConfig:y}=e,u=this.client.proposal.get(a);this.client.core.eventClient.deleteEvent({eventId:n.eventId});const{pairingTopic:g,proposer:_,requiredNamespaces:m,optionalNamespaces:v}=u;let d=(s=this.client.core.eventClient)==null?void 0:s.getEvent({topic:g});d||(d=(r=this.client.core.eventClient)==null?void 0:r.createEvent({type:h.EVENT_CLIENT_SESSION_TRACES.session_approve_started,properties:{topic:g,trace:[h.EVENT_CLIENT_SESSION_TRACES.session_approve_started,h.EVENT_CLIENT_SESSION_TRACES.session_namespaces_validation_success]}}));const R=await this.client.core.crypto.generateKeyPair(),V=_.publicKey,O=await this.client.core.crypto.generateSharedKey(R,V),N=f(f({relay:{protocol:c??"irn"},namespaces:p,controller:{publicKey:R,metadata:this.client.metadata},expiry:i.calcExpiry(M)},E&&{sessionProperties:E}),y&&{sessionConfig:y}),L=h.TRANSPORT_TYPES.relay;d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.subscribing_session_topic);try{await this.client.core.relayer.subscribe(O,{transportType:L})}catch(q){throw d.setError(h.EVENT_CLIENT_SESSION_ERRORS.subscribe_session_topic_failure),q}d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.subscribe_session_topic_success);const k=C(f({},N),{topic:O,requiredNamespaces:m,optionalNamespaces:v,pairingTopic:g,acknowledged:!1,self:N.controller,peer:{publicKey:_.publicKey,metadata:_.metadata},controller:R,transportType:h.TRANSPORT_TYPES.relay});await this.client.session.set(O,k),d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.store_session);try{d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.publishing_session_settle),await this.sendRequest({topic:O,method:"wc_sessionSettle",params:N,throwOnFailedPublish:!0}).catch(q=>{throw d?.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_settle_publish_failure),q}),d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.session_settle_publish_success),d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.publishing_session_approve),await this.sendResult({id:a,topic:g,result:{relay:{protocol:c??"irn"},responderPublicKey:R},throwOnFailedPublish:!0}).catch(q=>{throw d?.setError(h.EVENT_CLIENT_SESSION_ERRORS.session_approve_publish_failure),q}),d.addTrace(h.EVENT_CLIENT_SESSION_TRACES.session_approve_publish_success)}catch(q){throw this.client.logger.error(q),this.client.session.delete(O,i.getSdkError("USER_DISCONNECTED")),await this.client.core.relayer.unsubscribe(O),q}return this.client.core.eventClient.deleteEvent({eventId:d.eventId}),await this.client.core.pairing.updateMetadata({topic:g,metadata:_.metadata}),await this.client.proposal.delete(a,i.getSdkError("USER_DISCONNECTED")),await this.client.core.pairing.activate({topic:g}),await this.setExpiry(O,i.calcExpiry(M)),{topic:O,acknowledged:()=>Promise.resolve(this.client.session.get(O))}}),l(this,"reject",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidReject(e)}catch(n){throw this.client.logger.error("reject() -> isValidReject() failed"),n}const{id:t,reason:s}=e;let r;try{r=this.client.proposal.get(t).pairingTopic}catch(n){throw this.client.logger.error(`reject() -> proposal.get(${t}) failed`),n}r&&(await this.sendError({id:t,topic:r,error:s,rpcOpts:P.wc_sessionPropose.reject}),await this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED")))}),l(this,"update",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidUpdate(e)}catch(y){throw this.client.logger.error("update() -> isValidUpdate() failed"),y}const{topic:t,namespaces:s}=e,{done:r,resolve:n,reject:a}=i.createDelayedPromise(),c=w.payloadId(),p=w.getBigIntRpcId().toString(),E=this.client.session.get(t).namespaces;return this.events.once(i.engineEvent("session_update",c),({error:y})=>{y?a(y):n()}),await this.client.session.update(t,{namespaces:s}),await this.sendRequest({topic:t,method:"wc_sessionUpdate",params:{namespaces:s},throwOnFailedPublish:!0,clientRpcId:c,relayRpcId:p}).catch(y=>{this.client.logger.error(y),this.client.session.update(t,{namespaces:E}),a(y)}),{acknowledged:r}}),l(this,"extend",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidExtend(e)}catch(c){throw this.client.logger.error("extend() -> isValidExtend() failed"),c}const{topic:t}=e,s=w.payloadId(),{done:r,resolve:n,reject:a}=i.createDelayedPromise();return this.events.once(i.engineEvent("session_extend",s),({error:c})=>{c?a(c):n()}),await this.setExpiry(t,i.calcExpiry(M)),this.sendRequest({topic:t,method:"wc_sessionExtend",params:{},clientRpcId:s,throwOnFailedPublish:!0}).catch(c=>{a(c)}),{acknowledged:r}}),l(this,"request",async e=>{this.isInitialized();try{await this.isValidRequest(e)}catch(d){throw this.client.logger.error("request() -> isValidRequest() failed"),d}const{chainId:t,request:s,topic:r,expiry:n=P.wc_sessionRequest.req.ttl}=e,a=this.client.session.get(r);a?.transportType===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=w.payloadId(),p=w.getBigIntRpcId().toString(),{done:E,resolve:y,reject:u}=i.createDelayedPromise(n,"Request expired. Please try again.");this.events.once(i.engineEvent("session_request",c),({error:d,result:R})=>{d?u(d):y(R)});const g="wc_sessionRequest",_=this.getAppLinkIfEnabled(a.peer.metadata,a.transportType);if(_)return await this.sendRequest({clientRpcId:c,relayRpcId:p,topic:r,method:g,params:{request:C(f({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:t},expiry:n,throwOnFailedPublish:!0,appLink:_}).catch(d=>u(d)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:t,id:c}),await E();const m={request:C(f({},s),{expiryTimestamp:i.calcExpiry(n)}),chainId:t},v=this.shouldSetTVF(g,m);return await Promise.all([new Promise(async d=>{await this.sendRequest(f({clientRpcId:c,relayRpcId:p,topic:r,method:g,params:m,expiry:n,throwOnFailedPublish:!0},v&&{tvf:this.getTVFParams(c,m)})).catch(R=>u(R)),this.client.events.emit("session_request_sent",{topic:r,request:s,chainId:t,id:c}),d()}),new Promise(async d=>{var R;if(!((R=a.sessionConfig)!=null&&R.disableDeepLink)){const V=await i.getDeepLink(this.client.core.storage,pe);await i.handleDeeplinkRedirect({id:c,topic:r,wcDeepLink:V})}d()}),E()]).then(d=>d[2])}),l(this,"respond",async e=>{this.isInitialized(),await this.isValidRespond(e);const{topic:t,response:s}=e,{id:r}=s,n=this.client.session.get(t);n.transportType===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const a=this.getAppLinkIfEnabled(n.peer.metadata,n.transportType);w.isJsonRpcResult(s)?await this.sendResult({id:r,topic:t,result:s.result,throwOnFailedPublish:!0,appLink:a}):w.isJsonRpcError(s)&&await this.sendError({id:r,topic:t,error:s.error,appLink:a}),this.cleanupAfterResponse(e)}),l(this,"ping",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow();try{await this.isValidPing(e)}catch(s){throw this.client.logger.error("ping() -> isValidPing() failed"),s}const{topic:t}=e;if(this.client.session.keys.includes(t)){const s=w.payloadId(),r=w.getBigIntRpcId().toString(),{done:n,resolve:a,reject:c}=i.createDelayedPromise();this.events.once(i.engineEvent("session_ping",s),({error:p})=>{p?c(p):a()}),await Promise.all([this.sendRequest({topic:t,method:"wc_sessionPing",params:{},throwOnFailedPublish:!0,clientRpcId:s,relayRpcId:r}),n()])}else this.client.core.pairing.pairings.keys.includes(t)&&(this.client.logger.warn("ping() on pairing topic is deprecated and will be removed in the next major release."),await this.client.core.pairing.ping({topic:t}))}),l(this,"emit",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidEmit(e);const{topic:t,event:s,chainId:r}=e,n=w.getBigIntRpcId().toString(),a=w.payloadId();await this.sendRequest({topic:t,method:"wc_sessionEvent",params:{event:s,chainId:r},throwOnFailedPublish:!0,relayRpcId:n,clientRpcId:a})}),l(this,"disconnect",async e=>{this.isInitialized(),await this.confirmOnlineStateOrThrow(),await this.isValidDisconnect(e);const{topic:t}=e;if(this.client.session.keys.includes(t))await this.sendRequest({topic:t,method:"wc_sessionDelete",params:i.getSdkError("USER_DISCONNECTED"),throwOnFailedPublish:!0}),await this.deleteSession({topic:t,emitEvent:!1});else if(this.client.core.pairing.pairings.keys.includes(t))await this.client.core.pairing.disconnect({topic:t});else{const{message:s}=i.getInternalError("MISMATCHED_TOPIC",`Session or pairing topic not found: ${t}`);throw new Error(s)}}),l(this,"find",e=>(this.isInitialized(),this.client.session.getAll().filter(t=>i.isSessionCompatible(t,e)))),l(this,"getPendingSessionRequests",()=>this.client.pendingRequest.getAll()),l(this,"authenticate",async(e,t)=>{var s;this.isInitialized(),this.isValidAuthenticate(e);const r=t&&this.client.core.linkModeSupportedApps.includes(t)&&((s=this.client.metadata.redirect)==null?void 0:s.linkMode),n=r?h.TRANSPORT_TYPES.link_mode:h.TRANSPORT_TYPES.relay;n===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const{chains:a,statement:c="",uri:p,domain:E,nonce:y,type:u,exp:g,nbf:_,methods:m=[],expiry:v}=e,d=[...e.resources||[]],{topic:R,uri:V}=await this.client.core.pairing.create({methods:["wc_sessionAuthenticate"],transportType:n});this.client.logger.info({message:"Generated new pairing",pairing:{topic:R,uri:V}});const O=await this.client.core.crypto.generateKeyPair(),N=i.hashKey(O);if(await Promise.all([this.client.auth.authKeys.set(Y,{responseTopic:N,publicKey:O}),this.client.auth.pairingTopics.set(N,{topic:N,pairingTopic:R})]),await this.client.core.relayer.subscribe(N,{transportType:n}),this.client.logger.info(`sending request to new pairing topic: ${R}`),m.length>0){const{namespace:A}=i.parseChainId(a[0]);let b=i.createEncodedRecap(A,"request",m);i.getRecapFromResources(d)&&(b=i.mergeEncodedRecaps(b,d.pop())),d.push(b)}const L=v&&v>P.wc_sessionAuthenticate.req.ttl?v:P.wc_sessionAuthenticate.req.ttl,k={authPayload:{type:u??"caip122",chains:a,statement:c,aud:p,domain:E,version:"1",nonce:y,iat:new Date().toISOString(),exp:g,nbf:_,resources:d},requester:{publicKey:O,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(L)},q={eip155:{chains:a,methods:[...new Set(["personal_sign",...m])],events:["chainChanged","accountsChanged"]}},U={requiredNamespaces:{},optionalNamespaces:q,relays:[{protocol:"irn"}],pairingTopic:R,proposer:{publicKey:O,metadata:this.client.metadata},expiryTimestamp:i.calcExpiry(P.wc_sessionPropose.req.ttl),id:w.payloadId()},{done:xe,resolve:Ee,reject:Z}=i.createDelayedPromise(L,"Request expired"),$=w.payloadId(),H=i.engineEvent("session_connect",U.id),ee=i.engineEvent("session_request",$),j=async({error:A,session:b})=>{this.events.off(ee,te),A?Z(A):b&&Ee({session:b})},te=async A=>{var b,ye,_e;if(await this.deletePendingAuthRequest($,{message:"fulfilled",code:0}),A.error){const K=i.getSdkError("WC_METHOD_UNSUPPORTED","wc_sessionAuthenticate");return A.error.code===K.code?void 0:(this.events.off(H,j),Z(A.error.message))}await this.deleteProposal(U.id),this.events.off(H,j);const{cacaos:me,responder:D}=A.result,ie=[],Se=[];for(const K of me){await i.validateSignedCacao({cacao:K,projectId:this.client.core.projectId})||(this.client.logger.error(K,"Signature verification failed"),Z(i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed")));const{p:re}=K,ne=i.getRecapFromResources(re.resources),we=[i.getNamespacedDidChainId(re.iss)],De=i.getDidAddress(re.iss);if(ne){const oe=i.getMethodsFromRecap(ne),Me=i.getChainsFromRecap(ne);ie.push(...oe),we.push(...Me)}for(const oe of we)Se.push(`${oe}:${De}`)}const F=await this.client.core.crypto.generateSharedKey(O,D.publicKey);let Q;ie.length>0&&(Q={topic:F,acknowledged:!0,self:{publicKey:O,metadata:this.client.metadata},peer:D,controller:D.publicKey,expiry:i.calcExpiry(M),requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:R,namespaces:i.buildNamespacesFromAuth([...new Set(ie)],[...new Set(Se)]),transportType:n},await this.client.core.relayer.subscribe(F,{transportType:n}),await this.client.session.set(F,Q),R&&await this.client.core.pairing.updateMetadata({topic:R,metadata:D.metadata}),Q=this.client.session.get(F)),(b=this.client.metadata.redirect)!=null&&b.linkMode&&(ye=D.metadata.redirect)!=null&&ye.linkMode&&(_e=D.metadata.redirect)!=null&&_e.universal&&t&&(this.client.core.addLinkModeSupportedApp(D.metadata.redirect.universal),this.client.session.update(F,{transportType:h.TRANSPORT_TYPES.link_mode})),Ee({auths:me,session:Q})};this.events.once(H,j),this.events.once(ee,te);let se;try{if(r){const A=w.formatJsonRpcRequest("wc_sessionAuthenticate",k,$);this.client.core.history.set(R,A);const b=await this.client.core.crypto.encode("",A,{type:i.TYPE_2,encoding:i.BASE64URL});se=i.getLinkModeURL(t,R,b)}else await Promise.all([this.sendRequest({topic:R,method:"wc_sessionAuthenticate",params:k,expiry:e.expiry,throwOnFailedPublish:!0,clientRpcId:$}),this.sendRequest({topic:R,method:"wc_sessionPropose",params:U,expiry:P.wc_sessionPropose.req.ttl,throwOnFailedPublish:!0,clientRpcId:U.id})])}catch(A){throw this.events.off(H,j),this.events.off(ee,te),A}return await this.setProposal(U.id,U),await this.setAuthRequest($,{request:C(f({},k),{verifyContext:{}}),pairingTopic:R,transportType:n}),{uri:se??V,response:xe}}),l(this,"approveSessionAuthenticate",async e=>{const{id:t,auths:s}=e,r=this.client.core.eventClient.createEvent({properties:{topic:t.toString(),trace:[h.EVENT_CLIENT_AUTHENTICATE_TRACES.authenticated_session_approve_started]}});try{this.isInitialized()}catch(v){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.no_internet_connection),v}const n=this.getPendingAuthRequest(t);if(!n)throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_pending_request_not_found),new Error(`Could not find pending auth request with id ${t}`);const a=n.transportType||h.TRANSPORT_TYPES.relay;a===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const c=n.requester.publicKey,p=await this.client.core.crypto.generateKeyPair(),E=i.hashKey(c),y={type:i.TYPE_1,receiverPublicKey:c,senderPublicKey:p},u=[],g=[];for(const v of s){if(!await i.validateSignedCacao({cacao:v,projectId:this.client.core.projectId})){r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.invalid_cacao);const N=i.getSdkError("SESSION_SETTLEMENT_FAILED","Signature verification failed");throw await this.sendError({id:t,topic:E,error:N,encodeOpts:y}),new Error(N.message)}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.cacaos_verified);const{p:d}=v,R=i.getRecapFromResources(d.resources),V=[i.getNamespacedDidChainId(d.iss)],O=i.getDidAddress(d.iss);if(R){const N=i.getMethodsFromRecap(R),L=i.getChainsFromRecap(R);u.push(...N),V.push(...L)}for(const N of V)g.push(`${N}:${O}`)}const _=await this.client.core.crypto.generateSharedKey(p,c);r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.create_authenticated_session_topic);let m;if(u?.length>0){m={topic:_,acknowledged:!0,self:{publicKey:p,metadata:this.client.metadata},peer:{publicKey:c,metadata:n.requester.metadata},controller:c,expiry:i.calcExpiry(M),authentication:s,requiredNamespaces:{},optionalNamespaces:{},relay:{protocol:"irn"},pairingTopic:n.pairingTopic,namespaces:i.buildNamespacesFromAuth([...new Set(u)],[...new Set(g)]),transportType:a},r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribing_authenticated_session_topic);try{await this.client.core.relayer.subscribe(_,{transportType:a})}catch(v){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.subscribe_authenticated_session_topic_failure),v}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.subscribe_authenticated_session_topic_success),await this.client.session.set(_,m),r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.store_authenticated_session),await this.client.core.pairing.updateMetadata({topic:n.pairingTopic,metadata:n.requester.metadata})}r.addTrace(h.EVENT_CLIENT_AUTHENTICATE_TRACES.publishing_authenticated_session_approve);try{await this.sendResult({topic:E,id:t,result:{cacaos:s,responder:{publicKey:p,metadata:this.client.metadata}},encodeOpts:y,throwOnFailedPublish:!0,appLink:this.getAppLinkIfEnabled(n.requester.metadata,a)})}catch(v){throw r.setError(h.EVENT_CLIENT_AUTHENTICATE_ERRORS.authenticated_session_approve_publish_failure),v}return await this.client.auth.requests.delete(t,{message:"fulfilled",code:0}),await this.client.core.pairing.activate({topic:n.pairingTopic}),this.client.core.eventClient.deleteEvent({eventId:r.eventId}),{session:m}}),l(this,"rejectSessionAuthenticate",async e=>{this.isInitialized();const{id:t,reason:s}=e,r=this.getPendingAuthRequest(t);if(!r)throw new Error(`Could not find pending auth request with id ${t}`);r.transportType===h.TRANSPORT_TYPES.relay&&await this.confirmOnlineStateOrThrow();const n=r.requester.publicKey,a=await this.client.core.crypto.generateKeyPair(),c=i.hashKey(n),p={type:i.TYPE_1,receiverPublicKey:n,senderPublicKey:a};await this.sendError({id:t,topic:c,error:s,encodeOpts:p,rpcOpts:P.wc_sessionAuthenticate.reject,appLink:this.getAppLinkIfEnabled(r.requester.metadata,r.transportType)}),await this.client.auth.requests.delete(t,{message:"rejected",code:0}),await this.client.proposal.delete(t,i.getSdkError("USER_DISCONNECTED"))}),l(this,"formatAuthMessage",e=>{this.isInitialized();const{request:t,iss:s}=e;return i.formatMessage(t,s)}),l(this,"processRelayMessageCache",()=>{setTimeout(async()=>{if(this.relayMessageCache.length!==0)for(;this.relayMessageCache.length>0;)try{const e=this.relayMessageCache.shift();e&&await this.onRelayMessage(e)}catch(e){this.client.logger.error(e)}},50)}),l(this,"cleanupDuplicatePairings",async e=>{if(e.pairingTopic)try{const t=this.client.core.pairing.pairings.get(e.pairingTopic),s=this.client.core.pairing.pairings.getAll().filter(r=>{var n,a;return((n=r.peerMetadata)==null?void 0:n.url)&&((a=r.peerMetadata)==null?void 0:a.url)===e.peer.metadata.url&&r.topic&&r.topic!==t.topic});if(s.length===0)return;this.client.logger.info(`Cleaning up ${s.length} duplicate pairing(s)`),await Promise.all(s.map(r=>this.client.core.pairing.disconnect({topic:r.topic}))),this.client.logger.info("Duplicate pairings clean up finished")}catch(t){this.client.logger.error(t)}}),l(this,"deleteSession",async e=>{var t;const{topic:s,expirerHasDeleted:r=!1,emitEvent:n=!0,id:a=0}=e,{self:c}=this.client.session.get(s);await this.client.core.relayer.unsubscribe(s),await this.client.session.delete(s,i.getSdkError("USER_DISCONNECTED")),this.addToRecentlyDeleted(s,"session"),this.client.core.crypto.keychain.has(c.publicKey)&&await this.client.core.crypto.deleteKeyPair(c.publicKey),this.client.core.crypto.keychain.has(s)&&await this.client.core.crypto.deleteSymKey(s),r||this.client.core.expirer.del(s),this.client.core.storage.removeItem(pe).catch(p=>this.client.logger.warn(p)),this.getPendingSessionRequests().forEach(p=>{p.topic===s&&this.deletePendingSessionRequest(p.id,i.getSdkError("USER_DISCONNECTED"))}),s===((t=this.sessionRequestQueue.queue[0])==null?void 0:t.topic)&&(this.sessionRequestQueue.state=x.idle),n&&this.client.events.emit("session_delete",{id:a,topic:s})}),l(this,"deleteProposal",async(e,t)=>{if(t)try{const s=this.client.proposal.get(e),r=this.client.core.eventClient.getEvent({topic:s.pairingTopic});r?.setError(h.EVENT_CLIENT_SESSION_ERRORS.proposal_expired)}catch{}await Promise.all([this.client.proposal.delete(e,i.getSdkError("USER_DISCONNECTED")),t?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"proposal")}),l(this,"deletePendingSessionRequest",async(e,t,s=!1)=>{await Promise.all([this.client.pendingRequest.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)]),this.addToRecentlyDeleted(e,"request"),this.sessionRequestQueue.queue=this.sessionRequestQueue.queue.filter(r=>r.id!==e),s&&(this.sessionRequestQueue.state=x.idle,this.client.events.emit("session_request_expire",{id:e}))}),l(this,"deletePendingAuthRequest",async(e,t,s=!1)=>{await Promise.all([this.client.auth.requests.delete(e,t),s?Promise.resolve():this.client.core.expirer.del(e)])}),l(this,"setExpiry",async(e,t)=>{this.client.session.keys.includes(e)&&(this.client.core.expirer.set(e,t),await this.client.session.update(e,{expiry:t}))}),l(this,"setProposal",async(e,t)=>{this.client.core.expirer.set(e,i.calcExpiry(P.wc_sessionPropose.req.ttl)),await this.client.proposal.set(e,t)}),l(this,"setAuthRequest",async(e,t)=>{const{request:s,pairingTopic:r,transportType:n=h.TRANSPORT_TYPES.relay}=t;this.client.core.expirer.set(e,s.expiryTimestamp),await this.client.auth.requests.set(e,{authPayload:s.authPayload,requester:s.requester,expiryTimestamp:s.expiryTimestamp,id:e,pairingTopic:r,verifyContext:s.verifyContext,transportType:n})}),l(this,"setPendingSessionRequest",async e=>{const{id:t,topic:s,params:r,verifyContext:n}=e,a=r.request.expiryTimestamp||i.calcExpiry(P.wc_sessionRequest.req.ttl);this.client.core.expirer.set(t,a),await this.client.pendingRequest.set(t,{id:t,topic:s,params:r,verifyContext:n})}),l(this,"sendRequest",async e=>{const{topic:t,method:s,params:r,expiry:n,relayRpcId:a,clientRpcId:c,throwOnFailedPublish:p,appLink:E,tvf:y}=e,u=w.formatJsonRpcRequest(s,r,c);let g;const _=!!E;try{const d=_?i.BASE64URL:i.BASE64;g=await this.client.core.crypto.encode(t,u,{encoding:d})}catch(d){throw await this.cleanup(),this.client.logger.error(`sendRequest() -> core.crypto.encode() for topic ${t} failed`),d}let m;if(Oe.includes(s)){const d=i.hashMessage(JSON.stringify(u)),R=i.hashMessage(g);m=await this.client.core.verify.register({id:R,decryptedId:d})}const v=P[s].req;if(v.attestation=m,n&&(v.ttl=n),a&&(v.id=a),this.client.core.history.set(t,u),_){const d=i.getLinkModeURL(E,t,g);await global.Linking.openURL(d,this.client.name)}else{const d=P[s].req;n&&(d.ttl=n),a&&(d.id=a),d.tvf=C(f({},y),{correlationId:u.id}),p?(d.internal=C(f({},d.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(t,g,d)):this.client.core.relayer.publish(t,g,d).catch(R=>this.client.logger.error(R))}return u.id}),l(this,"sendResult",async e=>{const{id:t,topic:s,result:r,throwOnFailedPublish:n,encodeOpts:a,appLink:c}=e,p=w.formatJsonRpcResult(t,r);let E;const y=c&&typeof(global==null?void 0:global.Linking)<"u";try{const _=y?i.BASE64URL:i.BASE64;E=await this.client.core.crypto.encode(s,p,C(f({},a||{}),{encoding:_}))}catch(_){throw await this.cleanup(),this.client.logger.error(`sendResult() -> core.crypto.encode() for topic ${s} failed`),_}let u,g;try{u=await this.client.core.history.get(s,t);const _=u.request;try{this.shouldSetTVF(_.method,_.params)&&(g=this.getTVFParams(t,_.params,r))}catch(m){this.client.logger.warn("sendResult() -> getTVFParams() failed",m)}}catch(_){throw this.client.logger.error(`sendResult() -> history.get(${s}, ${t}) failed`),_}if(y){const _=i.getLinkModeURL(c,s,E);await global.Linking.openURL(_,this.client.name)}else{const _=u.request.method,m=P[_].res;m.tvf=C(f({},g),{correlationId:t}),n?(m.internal=C(f({},m.internal),{throwOnFailedPublish:!0}),await this.client.core.relayer.publish(s,E,m)):this.client.core.relayer.publish(s,E,m).catch(v=>this.client.logger.error(v))}await this.client.core.history.resolve(p)}),l(this,"sendError",async e=>{const{id:t,topic:s,error:r,encodeOpts:n,rpcOpts:a,appLink:c}=e,p=w.formatJsonRpcError(t,r);let E;const y=c&&typeof(global==null?void 0:global.Linking)<"u";try{const g=y?i.BASE64URL:i.BASE64;E=await this.client.core.crypto.encode(s,p,C(f({},n||{}),{encoding:g}))}catch(g){throw await this.cleanup(),this.client.logger.error(`sendError() -> core.crypto.encode() for topic ${s} failed`),g}let u;try{u=await this.client.core.history.get(s,t)}catch(g){throw this.client.logger.error(`sendError() -> history.get(${s}, ${t}) failed`),g}if(y){const g=i.getLinkModeURL(c,s,E);await global.Linking.openURL(g,this.client.name)}else{const g=u.request.method,_=a||P[g].res;this.client.core.relayer.publish(s,E,_)}await this.client.core.history.resolve(p)}),l(this,"cleanup",async()=>{const e=[],t=[];this.client.session.getAll().forEach(s=>{let r=!1;i.isExpired(s.expiry)&&(r=!0),this.client.core.crypto.keychain.has(s.topic)||(r=!0),r&&e.push(s.topic)}),this.client.proposal.getAll().forEach(s=>{i.isExpired(s.expiryTimestamp)&&t.push(s.id)}),await Promise.all([...e.map(s=>this.deleteSession({topic:s})),...t.map(s=>this.deleteProposal(s))])}),l(this,"onRelayEventRequest",async e=>{this.requestQueue.queue.push(e),await this.processRequestsQueue()}),l(this,"processRequestsQueue",async()=>{if(this.requestQueue.state===x.active){this.client.logger.info("Request queue already active, skipping...");return}for(this.client.logger.info(`Request queue starting with ${this.requestQueue.queue.length} requests`);this.requestQueue.queue.length>0;){this.requestQueue.state=x.active;const e=this.requestQueue.queue.shift();if(e)try{await this.processRequest(e)}catch(t){this.client.logger.warn(t)}}this.requestQueue.state=x.idle}),l(this,"processRequest",async e=>{const{topic:t,payload:s,attestation:r,transportType:n,encryptedId:a}=e,c=s.method;if(!this.shouldIgnorePairingRequest({topic:t,requestMethod:c}))switch(c){case"wc_sessionPropose":return await this.onSessionProposeRequest({topic:t,payload:s,attestation:r,encryptedId:a});case"wc_sessionSettle":return await this.onSessionSettleRequest(t,s);case"wc_sessionUpdate":return await this.onSessionUpdateRequest(t,s);case"wc_sessionExtend":return await this.onSessionExtendRequest(t,s);case"wc_sessionPing":return await this.onSessionPingRequest(t,s);case"wc_sessionDelete":return await this.onSessionDeleteRequest(t,s);case"wc_sessionRequest":return await this.onSessionRequest({topic:t,payload:s,attestation:r,encryptedId:a,transportType:n});case"wc_sessionEvent":return await this.onSessionEventRequest(t,s);case"wc_sessionAuthenticate":return await this.onSessionAuthenticateRequest({topic:t,payload:s,attestation:r,encryptedId:a,transportType:n});default:return this.client.logger.info(`Unsupported request method ${c}`)}}),l(this,"onRelayEventResponse",async e=>{const{topic:t,payload:s,transportType:r}=e,n=(await this.client.core.history.get(t,s.id)).request.method;switch(n){case"wc_sessionPropose":return this.onSessionProposeResponse(t,s,r);case"wc_sessionSettle":return this.onSessionSettleResponse(t,s);case"wc_sessionUpdate":return this.onSessionUpdateResponse(t,s);case"wc_sessionExtend":return this.onSessionExtendResponse(t,s);case"wc_sessionPing":return this.onSessionPingResponse(t,s);case"wc_sessionRequest":return this.onSessionRequestResponse(t,s);case"wc_sessionAuthenticate":return this.onSessionAuthenticateResponse(t,s);default:return this.client.logger.info(`Unsupported response method ${n}`)}}),l(this,"onRelayEventUnknownPayload",e=>{const{topic:t}=e,{message:s}=i.getInternalError("MISSING_OR_INVALID",`Decoded payload on topic ${t} is not identifiable as a JSON-RPC request or a response.`);throw new Error(s)}),l(this,"shouldIgnorePairingRequest",e=>{const{topic:t,requestMethod:s}=e,r=this.expectedPairingMethodMap.get(t);return!r||r.includes(s)?!1:!!(r.includes("wc_sessionAuthenticate")&&this.client.events.listenerCount("session_authenticate")>0)}),l(this,"onSessionProposeRequest",async e=>{const{topic:t,payload:s,attestation:r,encryptedId:n}=e,{params:a,id:c}=s;try{const p=this.client.core.eventClient.getEvent({topic:t});this.client.events.listenerCount("session_proposal")===0&&(console.warn("No listener for session_proposal event"),p?.setError(h.EVENT_CLIENT_PAIRING_ERRORS.proposal_listener_not_found)),this.isValidConnect(f({},s.params));const E=a.expiryTimestamp||i.calcExpiry(P.wc_sessionPropose.req.ttl),y=f({id:c,pairingTopic:t,expiryTimestamp:E},a);await this.setProposal(c,y);const u=await this.getVerifyContext({attestationId:r,hash:i.hashMessage(JSON.stringify(s)),encryptedId:n,metadata:y.proposer.metadata});p?.addTrace(h.EVENT_CLIENT_PAIRING_TRACES.emit_session_proposal),this.client.events.emit("session_proposal",{id:c,params:y,verifyContext:u})}catch(p){await this.sendError({id:c,topic:t,error:p,rpcOpts:P.wc_sessionPropose.autoReject}),this.client.logger.error(p)}}),l(this,"onSessionProposeResponse",async(e,t,s)=>{const{id:r}=t;if(w.isJsonRpcResult(t)){const{result:n}=t;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",result:n});const a=this.client.proposal.get(r);this.client.logger.trace({type:"method",method:"onSessionProposeResponse",proposal:a});const c=a.proposer.publicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",selfPublicKey:c});const p=n.responderPublicKey;this.client.logger.trace({type:"method",method:"onSessionProposeResponse",peerPublicKey:p});const E=await this.client.core.crypto.generateSharedKey(c,p);this.pendingSessions.set(r,{sessionTopic:E,pairingTopic:e,proposalId:r,publicKey:c});const y=await this.client.core.relayer.subscribe(E,{transportType:s});this.client.logger.trace({type:"method",method:"onSessionProposeResponse",subscriptionId:y}),await this.client.core.pairing.activate({topic:e})}else if(w.isJsonRpcError(t)){await this.client.proposal.delete(r,i.getSdkError("USER_DISCONNECTED"));const n=i.engineEvent("session_connect",r);if(this.events.listenerCount(n)===0)throw new Error(`emitting ${n} without any listeners, 954`);this.events.emit(n,{error:t.error})}}),l(this,"onSessionSettleRequest",async(e,t)=>{const{id:s,params:r}=t;try{this.isValidSessionSettleRequest(r);const{relay:n,controller:a,expiry:c,namespaces:p,sessionProperties:E,sessionConfig:y}=t.params,u=[...this.pendingSessions.values()].find(m=>m.sessionTopic===e);if(!u)return this.client.logger.error(`Pending session not found for topic ${e}`);const g=this.client.proposal.get(u.proposalId),_=C(f(f({topic:e,relay:n,expiry:c,namespaces:p,acknowledged:!0,pairingTopic:u.pairingTopic,requiredNamespaces:g.requiredNamespaces,optionalNamespaces:g.optionalNamespaces,controller:a.publicKey,self:{publicKey:u.publicKey,metadata:this.client.metadata},peer:{publicKey:a.publicKey,metadata:a.metadata}},E&&{sessionProperties:E}),y&&{sessionConfig:y}),{transportType:h.TRANSPORT_TYPES.relay});await this.client.session.set(_.topic,_),await this.setExpiry(_.topic,_.expiry),await this.client.core.pairing.updateMetadata({topic:u.pairingTopic,metadata:_.peer.metadata}),this.client.events.emit("session_connect",{session:_}),this.events.emit(i.engineEvent("session_connect",u.proposalId),{session:_}),this.pendingSessions.delete(u.proposalId),this.deleteProposal(u.proposalId,!1),this.cleanupDuplicatePairings(_),await this.sendResult({id:t.id,topic:e,result:!0,throwOnFailedPublish:!0})}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}}),l(this,"onSessionSettleResponse",async(e,t)=>{const{id:s}=t;w.isJsonRpcResult(t)?(await this.client.session.update(e,{acknowledged:!0}),this.events.emit(i.engineEvent("session_approve",s),{})):w.isJsonRpcError(t)&&(await this.client.session.delete(e,i.getSdkError("USER_DISCONNECTED")),this.events.emit(i.engineEvent("session_approve",s),{error:t.error}))}),l(this,"onSessionUpdateRequest",async(e,t)=>{const{params:s,id:r}=t;try{const n=`${e}_session_update`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,r)){this.client.logger.warn(`Discarding out of sync request - ${r}`),this.sendError({id:r,topic:e,error:i.getSdkError("INVALID_UPDATE_REQUEST")});return}this.isValidUpdate(f({topic:e},s));try{i.MemoryStore.set(n,r),await this.client.session.update(e,{namespaces:s.namespaces}),await this.sendResult({id:r,topic:e,result:!0,throwOnFailedPublish:!0})}catch(c){throw i.MemoryStore.delete(n),c}this.client.events.emit("session_update",{id:r,topic:e,params:s})}catch(n){await this.sendError({id:r,topic:e,error:n}),this.client.logger.error(n)}}),l(this,"isRequestOutOfSync",(e,t)=>t.toString().slice(0,-3)<e.toString().slice(0,-3)),l(this,"onSessionUpdateResponse",(e,t)=>{const{id:s}=t,r=i.engineEvent("session_update",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);w.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_update",s),{}):w.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_update",s),{error:t.error})}),l(this,"onSessionExtendRequest",async(e,t)=>{const{id:s}=t;try{this.isValidExtend({topic:e}),await this.setExpiry(e,i.calcExpiry(M)),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_extend",{id:s,topic:e})}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}}),l(this,"onSessionExtendResponse",(e,t)=>{const{id:s}=t,r=i.engineEvent("session_extend",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);w.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_extend",s),{}):w.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_extend",s),{error:t.error})}),l(this,"onSessionPingRequest",async(e,t)=>{const{id:s}=t;try{this.isValidPing({topic:e}),await this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.client.events.emit("session_ping",{id:s,topic:e})}catch(r){await this.sendError({id:s,topic:e,error:r}),this.client.logger.error(r)}}),l(this,"onSessionPingResponse",(e,t)=>{const{id:s}=t,r=i.engineEvent("session_ping",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);setTimeout(()=>{w.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_ping",s),{}):w.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_ping",s),{error:t.error})},500)}),l(this,"onSessionDeleteRequest",async(e,t)=>{const{id:s}=t;try{this.isValidDisconnect({topic:e,reason:t.params}),Promise.all([new Promise(r=>{this.client.core.relayer.once(h.RELAYER_EVENTS.publish,async()=>{r(await this.deleteSession({topic:e,id:s}))})}),this.sendResult({id:s,topic:e,result:!0,throwOnFailedPublish:!0}),this.cleanupPendingSentRequestsForTopic({topic:e,error:i.getSdkError("USER_DISCONNECTED")})]).catch(r=>this.client.logger.error(r))}catch(r){this.client.logger.error(r)}}),l(this,"onSessionRequest",async e=>{var t,s,r;const{topic:n,payload:a,attestation:c,encryptedId:p,transportType:E}=e,{id:y,params:u}=a;try{await this.isValidRequest(f({topic:n},u));const g=this.client.session.get(n),_=await this.getVerifyContext({attestationId:c,hash:i.hashMessage(JSON.stringify(w.formatJsonRpcRequest("wc_sessionRequest",u,y))),encryptedId:p,metadata:g.peer.metadata,transportType:E}),m={id:y,topic:n,params:u,verifyContext:_};await this.setPendingSessionRequest(m),E===h.TRANSPORT_TYPES.link_mode&&(t=g.peer.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp((s=g.peer.metadata.redirect)==null?void 0:s.universal),(r=this.client.signConfig)!=null&&r.disableRequestQueue?this.emitSessionRequest(m):(this.addSessionRequestToSessionRequestQueue(m),this.processSessionRequestQueue())}catch(g){await this.sendError({id:y,topic:n,error:g}),this.client.logger.error(g)}}),l(this,"onSessionRequestResponse",(e,t)=>{const{id:s}=t,r=i.engineEvent("session_request",s);if(this.events.listenerCount(r)===0)throw new Error(`emitting ${r} without any listeners`);w.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_request",s),{result:t.result}):w.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_request",s),{error:t.error})}),l(this,"onSessionEventRequest",async(e,t)=>{const{id:s,params:r}=t;try{const n=`${e}_session_event_${r.event.name}`,a=i.MemoryStore.get(n);if(a&&this.isRequestOutOfSync(a,s)){this.client.logger.info(`Discarding out of sync request - ${s}`);return}this.isValidEmit(f({topic:e},r)),this.client.events.emit("session_event",{id:s,topic:e,params:r}),i.MemoryStore.set(n,s)}catch(n){await this.sendError({id:s,topic:e,error:n}),this.client.logger.error(n)}}),l(this,"onSessionAuthenticateResponse",(e,t)=>{const{id:s}=t;this.client.logger.trace({type:"method",method:"onSessionAuthenticateResponse",topic:e,payload:t}),w.isJsonRpcResult(t)?this.events.emit(i.engineEvent("session_request",s),{result:t.result}):w.isJsonRpcError(t)&&this.events.emit(i.engineEvent("session_request",s),{error:t.error})}),l(this,"onSessionAuthenticateRequest",async e=>{var t;const{topic:s,payload:r,attestation:n,encryptedId:a,transportType:c}=e;try{const{requester:p,authPayload:E,expiryTimestamp:y}=r.params,u=await this.getVerifyContext({attestationId:n,hash:i.hashMessage(JSON.stringify(r)),encryptedId:a,metadata:p.metadata,transportType:c}),g={requester:p,pairingTopic:s,id:r.id,authPayload:E,verifyContext:u,expiryTimestamp:y};await this.setAuthRequest(r.id,{request:g,pairingTopic:s,transportType:c}),c===h.TRANSPORT_TYPES.link_mode&&(t=p.metadata.redirect)!=null&&t.universal&&this.client.core.addLinkModeSupportedApp(p.metadata.redirect.universal),this.client.events.emit("session_authenticate",{topic:s,params:r.params,id:r.id,verifyContext:u})}catch(p){this.client.logger.error(p);const E=r.params.requester.publicKey,y=await this.client.core.crypto.generateKeyPair(),u=this.getAppLinkIfEnabled(r.params.requester.metadata,c),g={type:i.TYPE_1,receiverPublicKey:E,senderPublicKey:y};await this.sendError({id:r.id,topic:s,error:p,encodeOpts:g,rpcOpts:P.wc_sessionAuthenticate.autoReject,appLink:u})}}),l(this,"addSessionRequestToSessionRequestQueue",e=>{this.sessionRequestQueue.queue.push(e)}),l(this,"cleanupAfterResponse",e=>{this.deletePendingSessionRequest(e.response.id,{message:"fulfilled",code:0}),setTimeout(()=>{this.sessionRequestQueue.state=x.idle,this.processSessionRequestQueue()},T.toMiliseconds(this.requestQueueDelay))}),l(this,"cleanupPendingSentRequestsForTopic",({topic:e,error:t})=>{const s=this.client.core.history.pending;s.length>0&&s.filter(r=>r.topic===e&&r.request.method==="wc_sessionRequest").forEach(r=>{const n=r.request.id,a=i.engineEvent("session_request",n);if(this.events.listenerCount(a)===0)throw new Error(`emitting ${a} without any listeners`);this.events.emit(i.engineEvent("session_request",r.request.id),{error:t})})}),l(this,"processSessionRequestQueue",()=>{if(this.sessionRequestQueue.state===x.active){this.client.logger.info("session request queue is already active.");return}const e=this.sessionRequestQueue.queue[0];if(!e){this.client.logger.info("session request queue is empty.");return}try{this.sessionRequestQueue.state=x.active,this.emitSessionRequest(e)}catch(t){this.client.logger.error(t)}}),l(this,"emitSessionRequest",e=>{this.client.events.emit("session_request",e)}),l(this,"onPairingCreated",e=>{if(e.methods&&this.expectedPairingMethodMap.set(e.topic,e.methods),e.active)return;const t=this.client.proposal.getAll().find(s=>s.pairingTopic===e.topic);t&&this.onSessionProposeRequest({topic:e.topic,payload:w.formatJsonRpcRequest("wc_sessionPropose",{requiredNamespaces:t.requiredNamespaces,optionalNamespaces:t.optionalNamespaces,relays:t.relays,proposer:t.proposer,sessionProperties:t.sessionProperties},t.id)})}),l(this,"isValidConnect",async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() params: ${JSON.stringify(e)}`);throw new Error(c)}const{pairingTopic:t,requiredNamespaces:s,optionalNamespaces:r,sessionProperties:n,relays:a}=e;if(i.isUndefined(t)||await this.isValidPairingTopic(t),!i.isValidRelays(a,!0)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`connect() relays: ${a}`);throw new Error(c)}!i.isUndefined(s)&&i.isValidObject(s)!==0&&this.validateNamespaces(s,"requiredNamespaces"),!i.isUndefined(r)&&i.isValidObject(r)!==0&&this.validateNamespaces(r,"optionalNamespaces"),i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")}),l(this,"validateNamespaces",(e,t)=>{const s=i.isValidRequiredNamespaces(e,"connect()",t);if(s)throw new Error(s.message)}),l(this,"isValidApprove",async e=>{if(!i.isValidParams(e))throw new Error(i.getInternalError("MISSING_OR_INVALID",`approve() params: ${e}`).message);const{id:t,namespaces:s,relayProtocol:r,sessionProperties:n}=e;this.checkRecentlyDeleted(t),await this.isValidProposalId(t);const a=this.client.proposal.get(t),c=i.isValidNamespaces(s,"approve()");if(c)throw new Error(c.message);const p=i.isConformingNamespaces(a.requiredNamespaces,s,"approve()");if(p)throw new Error(p.message);if(!i.isValidString(r,!0)){const{message:E}=i.getInternalError("MISSING_OR_INVALID",`approve() relayProtocol: ${r}`);throw new Error(E)}i.isUndefined(n)||this.validateSessionProps(n,"sessionProperties")}),l(this,"isValidReject",async e=>{if(!i.isValidParams(e)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() params: ${e}`);throw new Error(r)}const{id:t,reason:s}=e;if(this.checkRecentlyDeleted(t),await this.isValidProposalId(t),!i.isValidErrorReason(s)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`reject() reason: ${JSON.stringify(s)}`);throw new Error(r)}}),l(this,"isValidSessionSettleRequest",e=>{if(!i.isValidParams(e)){const{message:p}=i.getInternalError("MISSING_OR_INVALID",`onSessionSettleRequest() params: ${e}`);throw new Error(p)}const{relay:t,controller:s,namespaces:r,expiry:n}=e;if(!i.isValidRelay(t)){const{message:p}=i.getInternalError("MISSING_OR_INVALID","onSessionSettleRequest() relay protocol should be a string");throw new Error(p)}const a=i.isValidController(s,"onSessionSettleRequest()");if(a)throw new Error(a.message);const c=i.isValidNamespaces(r,"onSessionSettleRequest()");if(c)throw new Error(c.message);if(i.isExpired(n)){const{message:p}=i.getInternalError("EXPIRED","onSessionSettleRequest()");throw new Error(p)}}),l(this,"isValidUpdate",async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`update() params: ${e}`);throw new Error(c)}const{topic:t,namespaces:s}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const r=this.client.session.get(t),n=i.isValidNamespaces(s,"update()");if(n)throw new Error(n.message);const a=i.isConformingNamespaces(r.requiredNamespaces,s,"update()");if(a)throw new Error(a.message)}),l(this,"isValidExtend",async e=>{if(!i.isValidParams(e)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`extend() params: ${e}`);throw new Error(s)}const{topic:t}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t)}),l(this,"isValidRequest",async e=>{if(!i.isValidParams(e)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() params: ${e}`);throw new Error(c)}const{topic:t,request:s,chainId:r,expiry:n}=e;this.checkRecentlyDeleted(t),await this.isValidSessionTopic(t);const{namespaces:a}=this.client.session.get(t);if(!i.isValidNamespacesChainId(a,r)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() chainId: ${r}`);throw new Error(c)}if(!i.isValidRequest(s)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() ${JSON.stringify(s)}`);throw new Error(c)}if(!i.isValidNamespacesRequest(a,r,s.method)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() method: ${s.method}`);throw new Error(c)}if(n&&!i.isValidRequestExpiry(n,B)){const{message:c}=i.getInternalError("MISSING_OR_INVALID",`request() expiry: ${n}. Expiry must be a number (in seconds) between ${B.min} and ${B.max}`);throw new Error(c)}}),l(this,"isValidRespond",async e=>{var t;if(!i.isValidParams(e)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() params: ${e}`);throw new Error(n)}const{topic:s,response:r}=e;try{await this.isValidSessionTopic(s)}catch(n){throw(t=e?.response)!=null&&t.id&&this.cleanupAfterResponse(e),n}if(!i.isValidResponse(r)){const{message:n}=i.getInternalError("MISSING_OR_INVALID",`respond() response: ${JSON.stringify(r)}`);throw new Error(n)}}),l(this,"isValidPing",async e=>{if(!i.isValidParams(e)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`ping() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),l(this,"isValidEmit",async e=>{if(!i.isValidParams(e)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() params: ${e}`);throw new Error(a)}const{topic:t,event:s,chainId:r}=e;await this.isValidSessionTopic(t);const{namespaces:n}=this.client.session.get(t);if(!i.isValidNamespacesChainId(n,r)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() chainId: ${r}`);throw new Error(a)}if(!i.isValidEvent(s)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}if(!i.isValidNamespacesEvent(n,r,s.name)){const{message:a}=i.getInternalError("MISSING_OR_INVALID",`emit() event: ${JSON.stringify(s)}`);throw new Error(a)}}),l(this,"isValidDisconnect",async e=>{if(!i.isValidParams(e)){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`disconnect() params: ${e}`);throw new Error(s)}const{topic:t}=e;await this.isValidSessionOrPairingTopic(t)}),l(this,"isValidAuthenticate",e=>{const{chains:t,uri:s,domain:r,nonce:n}=e;if(!Array.isArray(t)||t.length===0)throw new Error("chains is required and must be a non-empty array");if(!i.isValidString(s,!1))throw new Error("uri is required parameter");if(!i.isValidString(r,!1))throw new Error("domain is required parameter");if(!i.isValidString(n,!1))throw new Error("nonce is required parameter");if([...new Set(t.map(c=>i.parseChainId(c).namespace))].length>1)throw new Error("Multi-namespace requests are not supported. Please request single namespace only.");const{namespace:a}=i.parseChainId(t[0]);if(a!=="eip155")throw new Error("Only eip155 namespace is supported for authenticated sessions. Please use .connect() for non-eip155 chains.")}),l(this,"getVerifyContext",async e=>{const{attestationId:t,hash:s,encryptedId:r,metadata:n,transportType:a}=e,c={verified:{verifyUrl:n.verifyUrl||h.VERIFY_SERVER,validation:"UNKNOWN",origin:n.url||""}};try{if(a===h.TRANSPORT_TYPES.link_mode){const E=this.getAppLinkIfEnabled(n,a);return c.verified.validation=E&&new URL(E).origin===new URL(n.url).origin?"VALID":"INVALID",c}const p=await this.client.core.verify.resolve({attestationId:t,hash:s,encryptedId:r,verifyUrl:n.verifyUrl});p&&(c.verified.origin=p.origin,c.verified.isScam=p.isScam,c.verified.validation=p.origin===new URL(n.url).origin?"VALID":"INVALID")}catch(p){this.client.logger.warn(p)}return this.client.logger.debug(`Verify context: ${JSON.stringify(c)}`),c}),l(this,"validateSessionProps",(e,t)=>{Object.values(e).forEach(s=>{if(!i.isValidString(s,!1)){const{message:r}=i.getInternalError("MISSING_OR_INVALID",`${t} must be in Record<string, string> format. Received: ${JSON.stringify(s)}`);throw new Error(r)}})}),l(this,"getPendingAuthRequest",e=>{const t=this.client.auth.requests.get(e);return typeof t=="object"?t:void 0}),l(this,"addToRecentlyDeleted",(e,t)=>{if(this.recentlyDeletedMap.set(e,t),this.recentlyDeletedMap.size>=this.recentlyDeletedLimit){let s=0;const r=this.recentlyDeletedLimit/2;for(const n of this.recentlyDeletedMap.keys()){if(s++>=r)break;this.recentlyDeletedMap.delete(n)}}}),l(this,"checkRecentlyDeleted",e=>{const t=this.recentlyDeletedMap.get(e);if(t){const{message:s}=i.getInternalError("MISSING_OR_INVALID",`Record was recently deleted - ${t}: ${e}`);throw new Error(s)}}),l(this,"isLinkModeEnabled",(e,t)=>{var s,r,n,a,c,p,E,y,u;return!e||t!==h.TRANSPORT_TYPES.link_mode?!1:((r=(s=this.client.metadata)==null?void 0:s.redirect)==null?void 0:r.linkMode)===!0&&((a=(n=this.client.metadata)==null?void 0:n.redirect)==null?void 0:a.universal)!==void 0&&((p=(c=this.client.metadata)==null?void 0:c.redirect)==null?void 0:p.universal)!==""&&((E=e?.redirect)==null?void 0:E.universal)!==void 0&&((y=e?.redirect)==null?void 0:y.universal)!==""&&((u=e?.redirect)==null?void 0:u.linkMode)===!0&&this.client.core.linkModeSupportedApps.includes(e.redirect.universal)&&typeof(global==null?void 0:global.Linking)<"u"}),l(this,"getAppLinkIfEnabled",(e,t)=>{var s;return this.isLinkModeEnabled(e,t)?(s=e?.redirect)==null?void 0:s.universal:void 0}),l(this,"handleLinkModeMessage",({url:e})=>{if(!e||!e.includes("wc_ev")||!e.includes("topic"))return;const t=i.getSearchParamFromURL(e,"topic")||"",s=decodeURIComponent(i.getSearchParamFromURL(e,"wc_ev")||""),r=this.client.session.keys.includes(t);r&&this.client.session.update(t,{transportType:h.TRANSPORT_TYPES.link_mode}),this.client.core.dispatchEnvelope({topic:t,message:s,sessionExists:r})}),l(this,"registerLinkModeListeners",async()=>{var e;if(i.isTestRun()||i.isReactNative()&&(e=this.client.metadata.redirect)!=null&&e.linkMode){const t=global==null?void 0:global.Linking;if(typeof t<"u"){t.addEventListener("url",this.handleLinkModeMessage,this.client.name);const s=await t.getInitialURL();s&&setTimeout(()=>{this.handleLinkModeMessage({url:s})},50)}}}),l(this,"shouldSetTVF",(e,t)=>{if(!t||e!=="wc_sessionRequest")return!1;const{request:s}=t;return Object.keys(de).includes(s.method)}),l(this,"getTVFParams",(e,t,s)=>{var r,n;try{const a=t.request.method,c=this.extractTxHashesFromResult(a,s);return C(f({correlationId:e,rpcMethods:[a],chainId:t.chainId},this.isValidContractData(t.request.params)&&{contractAddresses:[(n=(r=t.request.params)==null?void 0:r[0])==null?void 0:n.to]}),{txHashes:c})}catch(a){this.client.logger.warn("Error getting TVF params",a)}return{}}),l(this,"isValidContractData",e=>{var t;if(!e)return!1;try{const s=e?.data||((t=e?.[0])==null?void 0:t.data);if(!s.startsWith("0x"))return!1;const r=s.slice(2);return/^[0-9a-fA-F]*$/.test(r)?r.length%2===0:!1}catch{}return!1}),l(this,"extractTxHashesFromResult",(e,t)=>{try{const s=de[e];if(typeof t=="string")return[t];const r=t[s.key];if(i.isValidArray(r))return r;if(typeof r=="string")return[r]}catch(s){this.client.logger.warn("Error extracting tx hashes from result",s)}return[]})}isInitialized(){if(!this.initialized){const{message:o}=i.getInternalError("NOT_INITIALIZED",this.name);throw new Error(o)}}async confirmOnlineStateOrThrow(){await this.client.core.relayer.confirmOnlineStateOrThrow()}registerRelayerEvents(){this.client.core.relayer.on(h.RELAYER_EVENTS.message,o=>{!this.initialized||this.relayMessageCache.length>0?this.relayMessageCache.push(o):this.onRelayMessage(o)})}async onRelayMessage(o){const{topic:e,message:t,attestation:s,transportType:r}=o,{publicKey:n}=this.client.auth.authKeys.keys.includes(Y)?this.client.auth.authKeys.get(Y):{responseTopic:void 0,publicKey:void 0},a=await this.client.core.crypto.decode(e,t,{receiverPublicKey:n,encoding:r===h.TRANSPORT_TYPES.link_mode?i.BASE64URL:i.BASE64});try{w.isJsonRpcRequest(a)?(this.client.core.history.set(e,a),this.onRelayEventRequest({topic:e,payload:a,attestation:s,transportType:r,encryptedId:i.hashMessage(t)})):w.isJsonRpcResponse(a)?(await this.client.core.history.resolve(a),await this.onRelayEventResponse({topic:e,payload:a,transportType:r}),this.client.core.history.delete(e,a.id)):this.onRelayEventUnknownPayload({topic:e,payload:a,transportType:r})}catch(c){this.client.logger.error(c)}}registerExpirerEvents(){this.client.core.expirer.on(h.EXPIRER_EVENTS.expired,async o=>{const{topic:e,id:t}=i.parseExpirerTarget(o.target);if(t&&this.client.pendingRequest.keys.includes(t))return await this.deletePendingSessionRequest(t,i.getInternalError("EXPIRED"),!0);if(t&&this.client.auth.requests.keys.includes(t))return await this.deletePendingAuthRequest(t,i.getInternalError("EXPIRED"),!0);e?this.client.session.keys.includes(e)&&(await this.deleteSession({topic:e,expirerHasDeleted:!0}),this.client.events.emit("session_expire",{topic:e})):t&&(await this.deleteProposal(t,!0),this.client.events.emit("proposal_expire",{id:t}))})}registerPairingEvents(){this.client.core.pairing.events.on(h.PAIRING_EVENTS.create,o=>this.onPairingCreated(o)),this.client.core.pairing.events.on(h.PAIRING_EVENTS.delete,o=>{this.addToRecentlyDeleted(o.topic,"pairing")})}isValidPairingTopic(o){if(!i.isValidString(o,!1)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`pairing topic should be a string: ${o}`);throw new Error(e)}if(!this.client.core.pairing.pairings.keys.includes(o)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`pairing topic doesn't exist: ${o}`);throw new Error(e)}if(i.isExpired(this.client.core.pairing.pairings.get(o).expiry)){const{message:e}=i.getInternalError("EXPIRED",`pairing topic: ${o}`);throw new Error(e)}}async isValidSessionTopic(o){if(!i.isValidString(o,!1)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session topic should be a string: ${o}`);throw new Error(e)}if(this.checkRecentlyDeleted(o),!this.client.session.keys.includes(o)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`session topic doesn't exist: ${o}`);throw new Error(e)}if(i.isExpired(this.client.session.get(o).expiry)){await this.deleteSession({topic:o});const{message:e}=i.getInternalError("EXPIRED",`session topic: ${o}`);throw new Error(e)}if(!this.client.core.crypto.keychain.has(o)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session topic does not exist in keychain: ${o}`);throw await this.deleteSession({topic:o}),new Error(e)}}async isValidSessionOrPairingTopic(o){if(this.checkRecentlyDeleted(o),this.client.session.keys.includes(o))await this.isValidSessionTopic(o);else if(this.client.core.pairing.pairings.keys.includes(o))this.isValidPairingTopic(o);else if(i.isValidString(o,!1)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`session or pairing topic doesn't exist: ${o}`);throw new Error(e)}else{const{message:e}=i.getInternalError("MISSING_OR_INVALID",`session or pairing topic should be a string: ${o}`);throw new Error(e)}}async isValidProposalId(o){if(!i.isValidId(o)){const{message:e}=i.getInternalError("MISSING_OR_INVALID",`proposal id should be a number: ${o}`);throw new Error(e)}if(!this.client.proposal.keys.includes(o)){const{message:e}=i.getInternalError("NO_MATCHING_KEY",`proposal id doesn't exist: ${o}`);throw new Error(e)}if(i.isExpired(this.client.proposal.get(o).expiryTimestamp)){await this.deleteProposal(o);const{message:e}=i.getInternalError("EXPIRED",`proposal id: ${o}`);throw new Error(e)}}}class Ze extends h.Store{constructor(o,e){super(o,e,Te,J),this.core=o,this.logger=e}}class be extends h.Store{constructor(o,e){super(o,e,Ne,J),this.core=o,this.logger=e}}class et extends h.Store{constructor(o,e){super(o,e,fe,J,t=>t.id),this.core=o,this.logger=e}}class tt extends h.Store{constructor(o,e){super(o,e,Ae,G,()=>Y),this.core=o,this.logger=e}}class st extends h.Store{constructor(o,e){super(o,e,Ce,G),this.core=o,this.logger=e}}class it extends h.Store{constructor(o,e){super(o,e,Ve,G,t=>t.id),this.core=o,this.logger=e}}var rt=Object.defineProperty,nt=(S,o,e)=>o in S?rt(S,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):S[o]=e,ge=(S,o,e)=>nt(S,typeof o!="symbol"?o+"":o,e);class ot{constructor(o,e){this.core=o,this.logger=e,ge(this,"authKeys"),ge(this,"pairingTopics"),ge(this,"requests"),this.authKeys=new tt(this.core,this.logger),this.pairingTopics=new st(this.core,this.logger),this.requests=new it(this.core,this.logger)}async init(){await this.authKeys.init(),await this.pairingTopics.init(),await this.requests.init()}}var at=Object.defineProperty,ct=(S,o,e)=>o in S?at(S,o,{enumerable:!0,configurable:!0,writable:!0,value:e}):S[o]=e,I=(S,o,e)=>ct(S,typeof o!="symbol"?o+"":o,e);class W extends Ie.ISignClient{constructor(o){super(o),I(this,"protocol",ae),I(this,"version",ce),I(this,"name",z.name),I(this,"metadata"),I(this,"core"),I(this,"logger"),I(this,"events",new Re.EventEmitter),I(this,"engine"),I(this,"session"),I(this,"proposal"),I(this,"pendingRequest"),I(this,"auth"),I(this,"signConfig"),I(this,"on",(t,s)=>this.events.on(t,s)),I(this,"once",(t,s)=>this.events.once(t,s)),I(this,"off",(t,s)=>this.events.off(t,s)),I(this,"removeListener",(t,s)=>this.events.removeListener(t,s)),I(this,"removeAllListeners",t=>this.events.removeAllListeners(t)),I(this,"connect",async t=>{try{return await this.engine.connect(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"pair",async t=>{try{return await this.engine.pair(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"approve",async t=>{try{return await this.engine.approve(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"reject",async t=>{try{return await this.engine.reject(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"update",async t=>{try{return await this.engine.update(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"extend",async t=>{try{return await this.engine.extend(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"request",async t=>{try{return await this.engine.request(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"respond",async t=>{try{return await this.engine.respond(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"ping",async t=>{try{return await this.engine.ping(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"emit",async t=>{try{return await this.engine.emit(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"disconnect",async t=>{try{return await this.engine.disconnect(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"find",t=>{try{return this.engine.find(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"getPendingSessionRequests",()=>{try{return this.engine.getPendingSessionRequests()}catch(t){throw this.logger.error(t.message),t}}),I(this,"authenticate",async(t,s)=>{try{return await this.engine.authenticate(t,s)}catch(r){throw this.logger.error(r.message),r}}),I(this,"formatAuthMessage",t=>{try{return this.engine.formatAuthMessage(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"approveSessionAuthenticate",async t=>{try{return await this.engine.approveSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),I(this,"rejectSessionAuthenticate",async t=>{try{return await this.engine.rejectSessionAuthenticate(t)}catch(s){throw this.logger.error(s.message),s}}),this.name=o?.name||z.name,this.metadata=o?.metadata||i.getAppMetadata(),this.signConfig=o?.signConfig;const e=typeof o?.logger<"u"&&typeof o?.logger!="string"?o.logger:X.pino(X.getDefaultLoggerOptions({level:o?.logger||z.logger}));this.core=o?.core||new h.Core(o),this.logger=X.generateChildLogger(e,this.name),this.session=new be(this.core,this.logger),this.proposal=new Ze(this.core,this.logger),this.pendingRequest=new et(this.core,this.logger),this.engine=new We(this),this.auth=new ot(this.core,this.logger)}static async init(o){const e=new W(o);return await e.initialize(),e}get context(){return X.getLoggerContext(this.logger)}get pairing(){return this.core.pairing.pairings}async initialize(){this.logger.trace("Initialized");try{await this.core.start(),await this.session.init(),await this.proposal.init(),await this.pendingRequest.init(),await this.auth.init(),await this.engine.init(),this.logger.info("SignClient Initialization Success"),setTimeout(()=>{this.engine.processRelayMessageCache()},T.toMiliseconds(T.ONE_SECOND))}catch(o){throw this.logger.info("SignClient Initialization Failure"),this.logger.error(o.message),o}}}const lt=be,pt=W;exports.AUTH_CONTEXT=qe,exports.AUTH_KEYS_CONTEXT=Ae,exports.AUTH_PAIRING_TOPIC_CONTEXT=Ce,exports.AUTH_PROTOCOL=Pe,exports.AUTH_PUBLIC_KEY_NAME=Y,exports.AUTH_REQUEST_CONTEXT=Ve,exports.AUTH_STORAGE_PREFIX=G,exports.AUTH_VERSION=je,exports.ENGINE_CONTEXT=ve,exports.ENGINE_QUEUE_STATES=x,exports.ENGINE_RPC_OPTS=P,exports.HISTORY_CONTEXT=Ge,exports.HISTORY_EVENTS=Ke,exports.HISTORY_STORAGE_VERSION=Ye,exports.METHODS_TO_VERIFY=Oe,exports.PROPOSAL_CONTEXT=Te,exports.PROPOSAL_EXPIRY=He,exports.PROPOSAL_EXPIRY_MESSAGE=he,exports.REQUEST_CONTEXT=fe,exports.SESSION_CONTEXT=Ne,exports.SESSION_EXPIRY=M,exports.SESSION_REQUEST_EXPIRY_BOUNDARIES=B,exports.SIGN_CLIENT_CONTEXT=le,exports.SIGN_CLIENT_DEFAULT=z,exports.SIGN_CLIENT_EVENTS=$e,exports.SIGN_CLIENT_PROTOCOL=ae,exports.SIGN_CLIENT_STORAGE_OPTIONS=Fe,exports.SIGN_CLIENT_STORAGE_PREFIX=J,exports.SIGN_CLIENT_VERSION=ce,exports.SessionStore=lt,exports.SignClient=pt,exports.TVF_METHODS=de,exports.WALLETCONNECT_DEEPLINK_CHOICE=pe,exports.default=W;
//# sourceMappingURL=index.cjs.js.map
