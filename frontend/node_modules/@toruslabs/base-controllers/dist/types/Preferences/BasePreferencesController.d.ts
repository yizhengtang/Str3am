import type { OPENLOGIN_NETWORK_TYPE } from "@toruslabs/openlogin-utils";
import BaseController from "../BaseController";
import { BaseConfig, EmailObject, UserInfo } from "../interfaces";
import { BaseKeyringController } from "../Keyring/BaseKeyringController";
import { KeyringControllerState } from "../Keyring/IKeyringController";
import { TransactionStatus } from "../Transaction/ITransactionController";
import { AuthCredentials, IWSApiClient } from "../WSApiClient";
import { ACCOUNT_TYPE, AddressPreferences, BillboardEvent, ContactPayload, DiscoverDapp, PreferencesConfig, PreferencesState, THEME } from "./IPreferencesController";
export declare const DEFAULT_PREFERENCES: AddressPreferences;
/**
 * Controller that stores shared settings and exposes convenience methods
 */
export declare abstract class BasePreferencesController<P extends AddressPreferences, C extends PreferencesConfig, S extends PreferencesState<P>> extends BaseController<C, S> {
    /**
     * Name of this controller used during composition
     */
    name: string;
    iframeOrigin: string;
    protected wsApiClient: IWSApiClient;
    private signAuthMessage;
    private validateSignMessage;
    private defaultPreferences;
    /**
     * Creates a PreferencesController instance
     *
     * @param config - Initial options used to configure this controller
     * @param state - Initial state to set on this controller
     */
    constructor({ config, state, defaultPreferences, signAuthMessage, validateSignMessage, }: {
        config?: Partial<C> & Pick<C, "api" | "commonApiHost">;
        state?: Partial<S>;
        defaultPreferences?: Partial<P>;
        signAuthMessage: BaseKeyringController<BaseConfig, KeyringControllerState>["signAuthMessage"];
        validateSignMessage: (message: string) => Promise<void>;
    });
    setIframeOrigin(origin: string): void;
    getAddressState(address?: string): P | undefined;
    /**
     * Sets selected address
     *
     * @param selectedAddress - casper account hash
     */
    setSelectedAddress(selectedAddress: string): void;
    getUser<U>(address: string): Promise<U>;
    createUser(params: {
        selectedCurrency: string;
        theme: THEME;
        verifier: string;
        verifierId: string;
        locale: string;
        address: string;
        idToken?: string;
        type?: ACCOUNT_TYPE;
        web3AuthNetwork?: OPENLOGIN_NETWORK_TYPE;
    }): Promise<void>;
    storeUserLogin(params: {
        verifier: string;
        verifierId: string;
        address: string;
        options: {
            calledFromEmbed: boolean;
            rehydrate: boolean;
        };
        idToken?: string;
        web3AuthClientId?: string;
        web3AuthNetwork?: OPENLOGIN_NETWORK_TYPE;
        sessionPubKey?: string;
        loginMode?: string;
    }): Promise<void>;
    setCrashReport(isEnabled: boolean): Promise<boolean>;
    setUserTheme(theme: THEME): Promise<boolean>;
    setUserLocale(locale: string): Promise<boolean>;
    setSelectedCurrency(payload: {
        selectedCurrency: string;
    }): Promise<boolean>;
    addContact(contact: ContactPayload): Promise<boolean>;
    deleteContact(contactId: number): Promise<boolean>;
    revokeDiscord(idToken: string): Promise<void>;
    patchPastTx(body: {
        id: string;
        status: TransactionStatus;
        updated_at?: string;
    }, address: string): Promise<void>;
    postPastTx<T>(tx: T, address: string): Promise<{
        success: boolean;
        response: number[];
    }>;
    getWalletOrders<T>(address: string): Promise<T[]>;
    getTopUpOrders<T>(address: string): Promise<T[]>;
    getBillBoardData(): Promise<BillboardEvent[]>;
    getMessageForSigning(publicAddress: string, web3AuthIdToken?: string): Promise<string>;
    getTwitterId(payload: {
        nick: string;
        typeOfLogin: string;
    }): Promise<string>;
    sendEmail(payload: {
        emailObject: EmailObject;
    }): Promise<void>;
    refreshJwt(): Promise<void>;
    getDappList(): Promise<DiscoverDapp[]>;
    /**
     * Strategy
     * For account type: threshold, normal (web3auth login)
     * idToken from web3auth login must be present. We use it directly
     *
     * For account type: app_scoped, IMPORTED
     * idToken from web3auth login must be present. We request a message for signing using the idToken
     * and sign it using the private key of the account. We then send the signed message to the backend
     * to verify the signature and return a new jwtToken that includes the app_scoped address
     *
     * For account type: Account abstraction
     * idToken from web3auth login must be present. We use it to exchange for a new jwtToken.
     * Because backend can derive AA address from public address and issue this token easily.
     *
     * For account type: external
     * idToken from web3auth `authenticateUser` (siww) login must be present. We use it directly
     */
    protected init(params: {
        address: string;
        userInfo: UserInfo;
        type?: ACCOUNT_TYPE;
        idToken?: string;
        metadata?: Record<string, unknown>;
    }): Promise<void>;
    protected updateState(preferences?: Partial<P>, address?: string): P;
    protected authCredentials(address?: string): AuthCredentials;
    protected headers(address?: string): {
        headers: {
            Authorization: string;
            "Content-Type": string;
        };
    };
    abstract sync(address: string): Promise<boolean>;
}
